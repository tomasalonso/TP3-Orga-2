Ejercicio 7

  a) La estructura utilizada para el scheduler es la siguiente:
    Se tiene un uint para saber si el scheduler esta activo o no, una lista de uints con 17 posiciones las cuales
    representan los indices de la GDT que llevan al indice de la TSS de la respectiva tarea, las 8 primeras de jugador A,
    las segundas del jugador B y la ultima para la tarea idle.
    Hay un uint que indica el jugador actual (0 para A, 1 para B).
    Una tupla de uints que indica en la primera posicion el indice del ultimo pirata ejecutado del Jugador A y en la otra el del
    ultimo pirata ejecutado del jugador B en las dos listas siguientes.
    En estas dos listas se indica con un int si el pirata correspondiente al indice esta libre (0) o en ejecucion (1);
  b) La implementacion de sched_proxima_a_ejecutar es como sigue:
    en primer lugar se obtiene el jugador activo, el inactivo y se asigna una variable proximo con valor inicial de 16 (la tarea idle)
    Luego, si el scheduler esta activo chequea si el jugador inactivo tiene un slot para ejecutar, esto lo hace con la
    funcion sched_hay_slot_a_ejecutar, en esta funcion se recorre la lista de tareas del jugador indicado y si hay una que esta
    en ejecucion, se devuelve un 1, si no hay ninguna activa, devuelve 0.
    Si esta funcion retorna un 1, se cambia el jugador actual del scheduler por el que se tenia como inactivo y a proximo se le asigna
    el proximo slot de activo de este jugador con la funcion sched_proximo_slot_a_ejecutar, esta funcion recorre el array de slots
    del jugador a partir de la ultima tarea ejecutada (dandola vuelta y volviendo a la misma si no hay otra) y devolviendo el Indices
    de la proxima en la lista que este activa.
    Si el jugador inactivo no tiene un slot a ejecutar, chequea con sched_hay_slot_a_ejecutar lo mismo para el jugador activo y
    tambien asigna a proximo el indice de la proxima tarea de este jugador a ejecutar.
    Si ningun jugador esta activo, devuelve proximo como estaba (indicando la tarea idle).
  c) En sched_tick se llama primero a game_tick, luego a game_mineros_pendientes con el jugador actual del scheduler (se habla mas
    de esta funcion luego) y se define el indice de la proxima tarea a ejecutar llamando a sched_proxima_a_ejecutar.
    Finalmente se devuelve el indice de la GDT de la proxima tarea a ejecutar que se obtiene del atributo selectores del scheduler
    con el indice que se consigue en el paso anterior. tambien se modifica el llamado que hace la interrupcion del reloj a game_tick
    por sched_tick.
  d) El funcionamiento final de esta instruccion fue detallado en la seccion g) del ejercion 6.
  e) Esta modificacion ya se hizo dentro de sched_tick como se explico en la seccion c de este ejercicio.
  f) Aqui se modifico la macro que define el comportamiento de cada interrupcion. la unica diferencia entre las interrupciones
    son las que tienen error code y las que no. esto modifica el lugar en la pila de los parametros que se pasan a la funcion de C
    game_atender_excepcion, para solucionar esto, se chequea primero si la excepcion genera error code o no, en base a esto se define un
    offset para acceder a la pila y obtener los datos necesarios para luego ponerlos en el tope de la pila y llamar a la funcion de C.
    La funcion game_atender_excepcion se encarga de llamar a game__pirata_exploto para desalojar el pirata, ademas de chequar
    si se esta en modo debug (con una variable global que se pone en 0 o en 1) para frenar el scheduler, guardar la pantalla actual y mostrar la informacion de debug. de no estar
    en modo debug, vuelve a la interrupcion.
  g) cuando game_atender_excepcion entra en modo debug esta hace lo dicho anteriormente, guarda la pantalla actual con screen_guardar,
    imprime lo pedido por el modo debug con screen_debug la cual toma todos los parametros que se pasaron inicialmente por la pila
    el modo debug se inicia cuando se llama a la interrupcion del teclado presionando la tecla y, en este caso se chequea, si ya esta en modo
    debug simplemente se activa el scheduler y se continua la ejecucion. si no, se setea el indicador de debug en 1 lo cual desactivara
    el scheduler cuando haya una excepcion.




game_mineros_pendientes:
    esta funcion esta destinada a chequear si el jugador actual encontro algun botin pero en el momento no tenia lugar para enviar
    un minero.
    primero se chequea si el jugador tiene algun slot libre con sched_hay_slot_libre, si no lo hay se vuelve sin hacer nada,
    si lo hay, se cicla el arreglo botin del jugador, el cual indica con un 1 si el jugador vio ese botin y no lo envio a minar, o
    0 en caso contrario, si se da lo primero se llama a game_jugador_lanzar_minero con destino al botin no minado pero descubierto
    y se setea a cero la posicion correspondiente del arreglo botin del jugadro.

Estructura del mapa explorado:
    Cada jugador posee un arreglo mapa de 4 posiciones, cuanndo se inicializa el jugador se llama a game_jugador_inicializar_mapa,
    esta funcion se encarga de pedir cuatro paginas libres e iniciarlas como page tables vacias, se asigna a las cuatro posiciones
    del arreglo las 4 direcciones de memoria de estas paginas.
    Luego cada pirata tiene su page directory con el kernel y su codigo, se asignan a las cuatro entradas siguientes de este directorio
    las 4 posiciones de memoria de las tablas que se encuentran en el arreglo mapa de su jugador.
    Cuando un pirata se mueve, este tiene su posicion x e y, con estos valores obtiene las posiciones de memoria del mapa a las que se mueve
    y las mapea en este grupo de 4 tablas de paginas, entonces todos los piratas del jugador pueden "ver" lo explorado por los
    otros piratas.
