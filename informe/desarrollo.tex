\section{Desarrollo}

\subsection{Ejercicio 1}

A lo largo del TP se usan constantes ({\it \#defines\/}), como por ejemplo
en este ejercicio, donde usamos el índice de cada entrada de la {\bf GDT}, declarados
en el archivo {\it defines.h\/}.

Para completar cada entrada se usa la estructura dada por la cátedra sin
ninguna modificación, declarandose descriptores para 2 segmentos de datos y 2 de
código, siendo uno de cada tipo para {\it nivel 0\/} y {\it nivel 3\/}
({\it DPL 0\/} y {\it DPL 3\/}).

% insertar estructura

Se definió un segmento de datos especial para la memoria de video
({\it GDT_VIDEO\/}), el cual se usó solamente en este inciso y se comentó
posteriormente, por ende no se agrega a la GDT (puede apreciarse su código
comentado en el archivo {\it gdt.c\/}).

Luego, se carga la GDT y se salta a modo protegido tal como se vió en las clases
y los ejemplos, seteando el bit {\bf PE} del registro {\bf CR0}, realizando un
{\it jmp\/} con el selector de segmento de código correspondiente y cargando los
selectores de segmento de datos en los registros de segmentos {\it ds, ss, es,
gs\/} y {\it fs\/}.

Todos los segmentos se cargan con la modalidad {\bf flat} y apuntan a la misma
memoria (primeros 500MB). Se apunta la pila del kernel a la dirección
$0\times27000$, especificada por el enunciado, seteando el registro {\bf esp},
consecuentemente, se setea también el registro {\bf ebp}.

Ahora se carga el segmento especial de video y con código assembler se recorre
por medio de 2 ciclos anidados todas las posiciones del segmento, que comienzan
en la posición $0\times B8000$; es decir, se recorre cada posición de la
pantalla pintándola de gris.

De aquí en más se deshabilitó este segmento especial de video y se accede a la
memoria de video por los segmentos de datos. La inicializacion de la pantalla
se realiza en el {\it ejercicio 3\/} con funciones en C.


\subsection{Ejercicio 2}

Para inicializar las entradas de la {\bf IDT} se utilizo la macro {\it IDT_ENTRY\/}
propuesta con una ligera modificacion, se decidió agregar a la misma un
parámetro adicional, que permita especificar el atributo de la entrada,
definidos previamente.
Estas son {\bf TRAP}, la cual indica una trap gate usada para
las excepciones, {\bf INTERRUPT}, usada para interrupciones que solo pueden ser
llamadas por código de privilegio 0, y {\bf USER_INTERRUPT}, que puede ser llamada
por código de usuario también.

\begin{lstlisting}
#define IDT_ENTRY(numero, attribute)
  idt[numero].offset_0_15 = (unsigned short)
                ((unsigned int)(&_isr ## numero) & (unsigned int) 0xFFFF);
  idt[numero].segsel = (unsigned short) (GDT_IDX_ROOT_CODE << 3);
  idt[numero].attr = (unsigned short) attribute;
  idt[numero].offset_16_31 = (unsigned short) (
                (unsigned int)(&_isr ## numero) >> 16 & (unsigned int) 0xFFFF);

#define TRAP      0b1000111100000000
#define INTERRUPT 0b1000111000000000
#define USER_INTERRUPT 0b1110111000000000
\end{lstlisting}

Para la creación de las funciones de las excepciones de procesador se utiliza
otra macro, {\it ISR\/}, esta macro fue adaptada en este ejercicio para que
mostrara un mensaje de error de forma rudimentaria.

\begin{lstlisting}
%macro ISR 2
global _isr%1
  msg%1 db %2, 0
  msg%1_len equ    $ - msg%1
_isr%1:
  mov eax, %1
  imprimir_texto_mp msg%1, msg%1_len, 0x7, 0, 0
  iret
%endmacro
\end{lstlisting}

Cuando se produce una excepción, el descriptor llama a su función asignada
({\it _isrX\/}), la cual, dependiendo del número de interrupción se elige el
mensaje que se imprime por pantalla, esta funcionalidad será aprovechada más
adelante ya que son similares en cuanto a código todas las excepciones en este
tp.

El funcionamiento de la versión final de la macro se detalla mejor en la parte
correspondiente del ejercicio 7, cuando se implementa el verdadero
funcionamiento de las rutinas de atención
de estas excepciones.
% (HABLAR DE LA MACRO DE INTERRUPCIONES)

Una vez inicializada la IDT en el kernel con la macro, como se indica en el
enunciado, se probó a continuación el funcionamiento de varias excepciones.
Esto funcionó correctamente y luego fue comentado para seguir con el trabajo
práctico.



\subsection{Ejercicio 3}

En primer lugar se inicializa la pantalla con la función
{\it screen_inicializar\/} hecha en C.

Esta función utiliza todas funciones de la cátedra, entre ellas
{\it screen_pintar_rect\/}, {\it screen_pintar_linea_h\/},
{\it screen_pintar_puntajes\/}.

Los pasos a realizar por la función son, en primer lugar, pintar toda la
pantalla de gris; luego se pinta una línea negra en la parte superior, donde se
escribirá informacion, por el momento se escribe aquí el nombre del grupo, pero
luego se escribirá la tecla pulsada y el modo {\it debug\/}.
También se pintan los dos sectores de puntajes de los jugadores y se inicializan
los relojes para cada pirata de cada jugador. Todo lo realizado es acorde a las
imágenes del mapa sugerido por la cátedra.

Luego se implementó {\it mmu_inicializar_dir_kernel\/} que crea un
{\it page directory\/} para el kernel a partir de la dirección $0\times27000$
como indica el enunciado. En este page directory se crea una primera
{\it page table\/} que se ubica en la posición $0\times28000$, posición
asignada directamente y dicho sea de paso, en este punto, al no estar paginación
aún habilitada, pedir memoria libre no es una buena opción.

La {\it page table\/} se cicla con un incremento de 0 a 1024,
asignando páginas sucesivas, de modo que el esquema de paginación sea
{\bf identity mapping}; y para que ocurra efectivamente, se asigna la page table
en la primera entrada del page directory.
De modo que queda mapeada toda la sección del kernel y su memoria libre.
Como última aclaración, la sección del kernel corresponde al uso de la page
table en su totalidad (1024 entradas).

Finalmente se carga en el {\bf cr3} del kernel la dirección del page directory y
se habilita en el {\bf cr0} el bit de paginación.


\subsection{Ejercicio 4}

Se inicializa el seguimiento de las páginas libres con una variable global
({\it proxima_pagina_libre\/}) que comienza indicando el inicio del sector de
memoria libre, ubicado en la posición $0\times10000$. Con esta variable se
indica el lugar donde se reserva la próxima página pedida y luego se mueve una
posición hacia adelante. Este funcionamiento se implementó en la función
{\it mmu_proxima_pagina_fisica_libre\/}.

Luego se implementaron las funciones {\it mmu_mapear_pagina\/} y
{\it mmu_unmapear_pagina\/}, la primera accede al page directory indicado por
el parámetro {\it cr3\/} y chequea si la page table correspondiente a la
direccion virtual que se pide mapear está presente o no; si no lo está, se
reserva una página libre para alojarla, si lo esta, se apunta a la page table
indicada. En esta tabla setea en la entrada correspondiente a la dirección
virtual, los valores necesarios (base) para mapear a la dirección física, que
corresponden a los primeros 20 bits de la dirección, debido a que las páginas
están alineadas a 4kb. Se pone en presente posteriormente esta la entrada de la
página.

Finalmente se limpia el cache de páginas accedidas. Se agregó además un
parámetro adicional que permite elegir entre mapear la página como
solo lectura ({\bf RO}) o lectura/escritura ({\bf RW}).

Por otra parte, {\it mmu_unmapear_pagina\/} simplemente busca en el page
directory y en la page table correspondiente la entrada que estaba mapeando la
dirección virtual y setea a cero su bit de presente.

La implementación de la función {\it mmu_inicializar_dir_pirata\/} se detalla a
continuación separada por items:

\begin{itemize}
\item Se crea un page directory para el nuevo pirata, pidiendo una página libre, se
setea todo en cero para esta estructura, para evitar que basura de la memoria
mapee páginas no deseadas (de todas formas {\it bochs\/} setea a 0 la memoria
por defecto), y en la primera tabla se apunta a la misma page table que mapea el
kernel, siendo esta la dirección 0x28000, es propicio aclarar que todas las
tareas comparten la misma page table de identity mapping del kernel.

\item Luego se obtiene la direccion física en donde comienza el pirata, que en
el caso del TP, corresponde al puerto del jugador
({\it jugador.puertoX\/} y {\it jugador.puertoY\/}), notar que cambiando el
puerto de la estructura jugador, el pirata puede inicializar de cualquier otra
posición del mapa. Se localiza también con un puntero que se obtiene de
({\it jugador.codigo[tipo_pirata]}) la posición en memoria del codigo
correspondiente al tipo de pirata.

Estos valores de localización del código se asignan al comienzo del juego al
campo {\it codigo\/} de la estructura jugador, son paramétricos y pueden
modificarse si el código de las tareas cambia de ubicación.

\item Con el {\it cr3\/} actual se mapea en la dirección $0\times401000$ el lugar
donde va a ir localizado el código, se copia efectivamente el código a esta
dirección recien mapeada y se pone manualmente en las últimas posiciones de la
pila de la tarea los parámetros {\it x\/} e {\it y\/} necesarios por el código y
una dirección de retorno 0 la cual no va a ser llamada nunca. Finalmente se
desmapea esta dirección $0\times401000$.
Se utiliza la dirección $0\times401000$ porque es una dirección dentro del
segmento de datos que no será mapeada nunca en el TP por ninguna tarea.

\item Se termina por mapear, la dirección $0\times400000$ en el page directory
creado al comienzo de la función, con la posición en memoria a donde se copió el
código de la tarea en los pasos anteriores.
\begin{center}
\includegraphics[width=0.25\textwidth]{imagenes/parametrosTarea.png}

Pila de la tarea con los parámetros cargados
\end{center}

\item En las 4 tablas de páginas siguientes (entrada 2 a 5 inclusive del page
directory) se mapean 4 páginas que se reservaron al inicializar un jugador.

Estas corresponden a indicar las direcciones del mapa que ya son conocidas por
todos los piratas del jugador y se ven actualizadas con cada movimiento de los
piratas exploradores.

Estas 4 tablas de páginas se comparten por todos los piratas de cada jugador, de
esta manera, cada vez que un pirata explorador mapee una nueva posición del mapa
con la función {\it mmu_mapear_pagina\/}, la posición estará mapeada para todos
los piratas del jugador y por ejemplo, un minero se podrá mover a dicha posición.

Por último se exploran las 9 posiciones en la que se crea el pirata, esto es
solo útil para el primer pirata. Al realizarse siempre, las posiciones ya
podrían estar exploradas por piratas previos. Luego se devuelve el page
directory del pirata recién creado. Para realizar esto, se llama a
\hbox{\it game_explorar_posicion(pirata_a_crear, page_directory_del_pirata, puertoX, puertoY, TODO)}
(ver en funciones propias).
\end{itemize}

\subsection{Ejercicio 5}

Se crean las 3 entradas en la IDT para las 3 interrupciones indicadas con:
\begin{lstlisting}
/* Agregamos entrada para interrupcion del clock */
IDT_ENTRY(32, INTERRUPT);
/* Agregamos entrada para interrupcion del teclado */
IDT_ENTRY(33, INTERRUPT);
/* Agregamos entrada para interrupcion de software 0x46 */
IDT_ENTRY(70, USER_INTERRUPT);
\end{lstlisting}

Y las 3 funciones {\it _isr32\/}, {\it _isr_33\/} e {\it _isr70\/}.

Luego se activa el PIC con {\it resetear_pic\/} y {\it habilitar_pic\/}.

En la interrupción del reloj se avisa al PIC que se atendió la interrupción con
{\it fin_intr_pic1} y se realizaba lo pedido en el enunciado, llamándose a
{\it game_tick\/} que actualizaba el reloj del sistema.

(HABLAR DE LAS 3 INTERRUPCIONES AL FINAL)

En la interrupción del teclado también se llama a {\it fin_intr_pic1\/} y luego
a la función \hbox{\it game_atender_teclado\/}, la cual en primer lugar solo se
encargaba de imprimir en pantalla la tecla usando un switch y los distintos
códigos de teclado.

Se hablará en mayor profundidad de esta y las otras
interrupciones cuando se trate su implementación final.

Finalmente se agrega la interrupcion 0x46, la cual no hacia nada útil. Se
posterga la explicación de su funcionamiento final más adelante cuando es
correctamente implementada.


\subsection{Ejercicio 6}

Se agrega en la GDT un descriptor de {\bf TSS} para la tarea {\it inicial\/},
uno para la tarea {\it idle\/}, 8 para los piratas de jugador A y otras 8 para
los piratas del jugador B. Todos los descriptores poseen {\it DPL 0\/}, de modo
que las tareas de usuario no puedan realizar cambio de contexto y solo puedan
ser realizados por código nivel kernel.

En la función {\it tss_inicializar\/} se configura la TSS de la tarea inicial y
de la tarea idle como se pide, creando estas como variables globales en el
código ({\it tss_inicial} y {\it tss_idle}) y modificando esta estructura con
los valores correspondientes.

Primero para la tss inicial y la idle se asigna su dirección (base) en su
descriptor correspondiente de la GDT y se ponen en 1 el bit de presente.

Se inicializa la estructura de la TSS de la tarea idle, esto significa, setear
la pila local y la pila de nivel 0 ambas en la del kernel ($0\times27000$),
el cr3 actual que es el perteneciente al kernel y los eflags con valor
$0\times202$ que activa las interrupciones enmascarables y el {\bf eip}
apuntando a la posicion $0\times16000$ como pide el enunciado, que corresponde
a la posición donde se ubica el código de la tarea.
Luego se asignan los segmentos de privilegio 0, y el {\it rpl\/} del selector a
0.

Finalmente en un ciclo se inicializan las bases y el bit de presente de todas
los descriptores de TSS de los piratas, que son inicializadas con los valores
posteriormente cuando se lanza un pirata.

Para inicializar las TSS de los piratas, se pide una página para la pila de
nivel 0 y asignando la base y el {\it esp\/} al final de esta página, seteando
su pila local al final de su pagina asignada, pero con el esp 3 posiciones
arriba asumiendo que tiene los dos parámetros y la posición de retorno que se
pasan en la pila.

También se asigna el eip apuntando al principio de la página de código
($0\times400000$). El {\it eflags\/} con valor $0\times202$ y con todos los
segmentos de nivel 3 y RPL 3, es decir, con privilegios de usuario.

Se escribe el código necesario para cargar la tarea inicial como la actual,
cargando el selector de la tarea inicial con {\it ltr\/} e inmediatamente salta
a la tarea idle.

(ESTO ACA O EN EL EJERCICIO 7?)
Modificamos la interrupción 0x46 la cual ahora pone en la pila los parametros que se le pasan
y llama a game_syscall_manejar. Esta le pide al scheduler cual es el jugador actual y el pirata actual,
con una serie de ifs chequea cual fue el servicio pedido y llama a game_syscall_pirata_mover, game_syscall_cavar o
game_syscall_pirata_posicion. si no es nungun caso destruye al pirata y devuelve un -1.
  La funcion game_syscall_pirata_mover en primer lugar chequea que se haya pedido mover con una
  direccion valida y hacia una posicion valida, luego se chequea si el pirata es un explorador.
  Si se cumplen estas condiciones, se llama a game_explorar_posicion con el pirata, el cr3 del kernel, la nueva
  posicion (X,Y) y la direccion, luego se llama a game_pirata_mover. si el pirata no es un explorador,
  solo se llama a game_pirata_mover. si la direccion o la posicion no eran validas, se llama a game_pirata_exploto
  y se devuelve un -1. si se movio correctamente, se devuelve un 0.

Cuando retorna a la interrupcion, esta acomoda la pila, recupera el resultado y chequea si se devolvio un -1,
en este caso salta a la tarea idle, si no, se fija si se intento pedir la posicion, si fue asi, manualmente se
pone en la pila en el registro guardado de la tarea la posicion actual de la misma y tambien se salta a la tarea idle.


Ejercicio 7

  a) La estructura utilizada para el scheduler es la siguiente:
    Se tiene un uint para saber si el scheduler esta activo o no, una lista de uints con 17 posiciones las cuales
    representan los indices de la GDT que llevan al indice de la TSS de la respectiva tarea, las 8 primeras de jugador A,
    las segundas del jugador B y la ultima para la tarea idle.
    Hay un uint que indica el jugador actual (0 para A, 1 para B).
    Una tupla de uints que indica en la primera posicion el indice del ultimo pirata ejecutado del Jugador A y en la otra el del
    ultimo pirata ejecutado del jugador B en las dos listas siguientes.
    En estas dos listas se indica con un int si el pirata correspondiente al indice esta libre (0) o en ejecucion (1);
  b) La implementacion de sched_proxima_a_ejecutar es como sigue:
    en primer lugar se obtiene el jugador activo, el inactivo y se asigna una variable proximo con valor inicial de 16 (la tarea idle)
    Luego, si el scheduler esta activo chequea si el jugador inactivo tiene un slot para ejecutar, esto lo hace con la
    funcion sched_hay_slot_a_ejecutar, en esta funcion se recorre la lista de tareas del jugador indicado y si hay una que esta
    en ejecucion, se devuelve un 1, si no hay ninguna activa, devuelve 0.
    Si esta funcion retorna un 1, se cambia el jugador actual del scheduler por el que se tenia como inactivo y a proximo se le asigna
    el proximo slot de activo de este jugador con la funcion sched_proximo_slot_a_ejecutar, esta funcion recorre el array de slots
    del jugador a partir de la ultima tarea ejecutada (dandola vuelta y volviendo a la misma si no hay otra) y devolviendo el Indices
    de la proxima en la lista que este activa.
    Si el jugador inactivo no tiene un slot a ejecutar, chequea con sched_hay_slot_a_ejecutar lo mismo para el jugador activo y
    tambien asigna a proximo el indice de la proxima tarea de este jugador a ejecutar.
    Si ningun jugador esta activo, devuelve proximo como estaba (indicando la tarea idle).
  c) En sched_tick se llama primero a game_tick, luego a game_mineros_pendientes con el jugador actual del scheduler (se habla mas
    de esta funcion luego) y se define el indice de la proxima tarea a ejecutar llamando a sched_proxima_a_ejecutar.
    Finalmente se devuelve el indice de la GDT de la proxima tarea a ejecutar que se obtiene del atributo selectores del scheduler
    con el indice que se consigue en el paso anterior. tambien se modifica el llamado que hace la interrupcion del reloj a game_tick
    por sched_tick.
  d) El funcionamiento final de esta instruccion fue detallado en la seccion g) del ejercion 6.
  e) Esta modificacion ya se hizo dentro de sched_tick como se explico en la seccion c de este ejercicio.
  f) Aqui se modifico la macro que define el comportamiento de cada interrupcion. la unica diferencia entre las interrupciones
    son las que tienen error code y las que no. esto modifica el lugar en la pila de los parametros que se pasan a la funcion de C
    game_atender_excepcion, para solucionar esto, se chequea primero si la excepcion genera error code o no, en base a esto se define un
    offset para acceder a la pila y obtener los datos necesarios para luego ponerlos en el tope de la pila y llamar a la funcion de C.
    La funcion game_atender_excepcion se encarga de llamar a game__pirata_exploto para desalojar el pirata, ademas de chequar
    si se esta en modo debug (con una variable global que se pone en 0 o en 1) para frenar el scheduler, guardar la pantalla actual y mostrar la informacion de debug. de no estar
    en modo debug, vuelve a la interrupcion.
  g) cuando game_atender_excepcion entra en modo debug esta hace lo dicho anteriormente, guarda la pantalla actual con screen_guardar,
    imprime lo pedido por el modo debug con screen_debug la cual toma todos los parametros que se pasaron inicialmente por la pila
    el modo debug se inicia cuando se llama a la interrupcion del teclado presionando la tecla y, en este caso se chequea, si ya esta en modo
    debug simplemente se activa el scheduler y se continua la ejecucion. si no, se setea el indicador de debug en 1 lo cual desactivara
    el scheduler cuando haya una excepcion.


Estructura del mapa explorado:
    Cada jugador posee un arreglo mapa de 4 posiciones, cuanndo se inicializa el jugador se llama a game_jugador_inicializar_mapa,
    esta funcion se encarga de pedir cuatro paginas libres e iniciarlas como page tables vacias, se asigna a las cuatro posiciones
    del arreglo las 4 direcciones de memoria de estas paginas.
    Luego cada pirata tiene su page directory con el kernel y su codigo, se asignan a las cuatro entradas siguientes de este directorio
    las 4 posiciones de memoria de las tablas que se encuentran en el arreglo mapa de su jugador.
    Cuando un pirata se mueve, este tiene su posicion x e y, con estos valores obtiene las posiciones de memoria del mapa a las que se mueve
    y las mapea en este grupo de 4 tablas de paginas, entonces todos los piratas del jugador pueden "ver" lo explorado por los
    otros piratas.

Estructura Jugador:
    La estructura jugador es la encargada de tener la informacion que comparten todos los piratas asi como
    su puntaje, su puerto y donde se encuentra el codigo de sus tareas.
    La estructura tiene los siguientes atributos:
      Un identificador index (0 para A, 1 para B).
      Un arreglo de piratas cuya capacidad maxima es el total de los que puede tener vivos.
      La cantidad de monedas que tiene recolectadas y su color.
      Un arreglo de 4 posiciones con las direcciones de memoria de las tablas de paginas que se usaran para mapear el mapa visto por
      sus piratas.
      Las posiciones X e Y de su puerto.
      Las dos direcciones a los codigos de sus piratas, minero o explorador.
      un arreglo con tantas posiciones como botines hay en el mapa el cual sirve para indicar cual fue descubierto pero aun no se le envio
      un minero.

Estructura Pirata:
    La estructura pirata se encarga de conocer a su jugador, su posicion actual y su tipo.
    Esta tiene los siguientes atributos:
      Un index que define que numero de pirata es para su jugador.
      Tiene un puntero a una estructura Jugador, el cual apunta a su jugador.
      Sus posiciones X e Y en el mapa.
      Su tipo (explorador o minero).

Estructura Scheduler:
    La estructura scheduler es la encargada de saber que jugador esta activo en este momento y tener la informacion
    necesaria para saber que tarea ejecutar en el proximo ciclo del reloj.
    Esta posee los siguientes atributos:
      activo: Indica si el scheduler esta actualmente manejando el juego o no.
      selectores: Este arreglo de 17 posiciones tiene los selectores de las entradas de la GDT de
      las 8 tareas del jugador A, las 8 del B y la tarea idle.
      jugadorActual: Como era de esperarse, indica el jugador actualmente activo.
      slotActual: Es una tupla la cual posee el indice del arreglo slots de la ultima tarea ejecutada por el jugador A
      en su primer valor, y del jugador B en su segundo valor.
      slots: esta tupla de dos arreglos de ocho posiciones indica en cada una de ellas si la tarea correspondiente a ese
      indice (para el jugador A en el primer arreglo y el jugador B en el segundo) esta fuera del juegp (0) o esta actualmente
      en el mapa activa (1).

Funciones creadas:

game_mineros_pendientes:
    esta funcion esta destinada a chequear si el jugador actual encontro algun botin pero en el momento no tenia lugar para enviar
    un minero.
    primero se chequea si el jugador tiene algun slot libre con sched_hay_slot_libre, si no lo hay se vuelve sin hacer nada,
    si lo hay, se cicla el arreglo botin del jugador, el cual indica con un 1 si el jugador vio ese botin y no lo envio a minar, o
    0 en caso contrario, si se da lo primero se llama a game_jugador_lanzar_minero con destino al botin no minado pero descubierto
    y se setea a cero la posicion correspondiente del arreglo botin del jugadro.

  game_minar_botin:
    Esta funcion toma dos parametros que indican una posicion por sus coordenadas X e Y.
    dentro de ella se cicla tantas veces como botines haya y si uno de esos botines esta ubicado en la
    posicion (X,Y) se le resta una moneda al botin y se sale del ciclo.

  La funcion game_lineal2virtual se encarga de pasar de direcciones lineales del mapa a las direcciones
  virtuales correspondientes a la posicion correspondiente a las estructuras de paginacion para el mapa.

  La funcion game_lineal2physical se encarga de pasar de direcciones lineales del mapa a las direcciones
  fisicas correspondientes a la misma posicion pero del mapa en memoria.

  game_actualizar_codigo:
    Esta funcion toma dos puntos (X0,Y0) y (X1,Y1).
    con (X0,Y0) obtiene la direccion virtual para esas coordenadas, que es donde esta el codigo de la tarea ahora
    con (X1,Y1) obtiene la direccion fisica en donde se va a pasar el codigo de la tarea cuando esta se haya movido
    luego se mapea en la direccion 0x400000 la pagina fisica recien obtenida
    para despues copiar desde la posicion actual a la posicion 0x400000, la cual apunta a la nueva posicion de la tarea

  game_explorar_posicion:
  game_pirata_mover:


  game_calcular_fin:
    Esta funcion chequea si el contador del juego es igual a la variable global FIN, en ese caso se llama a game_terminar_si_es_hora
    y se devuelve un 1.
    Luego si el scheduler esta activo y ambos jugadores tienen todos los slots ocupados y sus puntajes no cambiaron
    (chequeado con dos variables globales puntajeA y puntajeB comparadas con el atributo monedas de cada jugador)
    entonces crece el contador.
    si algo de esto no se cumple, se resetea el contador y se actualizan las variables globales de puntaje de cada jugador.
    finalmente se devuelve un 0.
